<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: AIS: Custom Presentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open CASCADE Technology"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorials__ais_object.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">AIS: Custom Presentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Getting Started</a></li>
<li class="level1"><a href="#prs_builders">Presentation builders</a></li>
<li class="level1"><a href="#prim_arrays">Primitive arrays</a></li>
<li class="level1"><a href="#prim_aspects">Primitive aspects</a></li>
<li class="level1"><a href="#quadric_builders">Quadric builders</a></li>
<li class="level1"><a href="#ais_selection">Computing selection</a></li>
<li class="level1"><a href="#sel_owner_highlight">Highlighting selection owner</a></li>
<li class="level1"><a href="#highlight_apporaches">Highlighting approaches</a></li>
<li class="level1"><a href="#mouse_click">Mouse click</a></li>
<li class="level1"><a href="#final">Final result</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Getting Started</h1>
<p>OCCT provides a strong set of built-in Interactive Objects for rapid application development, but the real power and flexibility of <b>Application Interactive Services</b> (<code>AIS</code>) could be revealed by subclassing and implementing custom presentations. In this tutorial we will focus on the development of a custom <code>AIS_InteractiveObject</code> and show the basics step by step.</p>
<p>Let's start from the very beginning and try subclassing <code>AIS_InteractiveObject</code> object:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisObject : <span class="keyword">public</span> AIS_InteractiveObject</div>
<div class="line">{</div>
<div class="line">  DEFINE_STANDARD_RTTI_INLINE(MyAisObject, AIS_InteractiveObject)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyAisObject() {}</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                        <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                        <span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> override </span>{}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                 <span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> override </span>{}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> AcceptDisplayMode (<span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> const override</span></div>
<div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>DEFINE_STANDARD_RTTI_INLINE()</code> macro will register the new class within the OCCT Run-Time Type Information (RTTI) system. This step is optional (you may skip it if you are not going to use methods like <code>Standard_Transient::DynamicType()</code> in application code), but it is a common practice while subclassing OCCT classes.</p>
<p>The <code>AIS_InteractiveObject</code> interface defines only a couple of pure virtual methods - <code>::Compute()</code> defining an object presentation and <code>::ComputeSelection()</code> defining a selectable (pickable) volume. Selection and presentation are two independent mechanisms in <b>AIS</b>. Presentation rendering is done with help of OpenGL or a similar low-level graphics library, while selection doesn't depend on a graphic driver at all. Providing an empty implementation of these two methods would be enough for adding the object to <code>AIS_InteractiveContext</code> (<code>::Display()</code>), but obviously nothing will appear on the screen.</p>
<h1><a class="anchor" id="prs_builders"></a>
Presentation builders</h1>
<p>To go ahead, we need to define some presentation of our object. OCCT provides a set of presentation building tools for common elements like arrows, shapes, boxes, etc. These tools could be found within <code>Prs3d</code>, <code>StdPrs</code> and <code>DsgPrs</code> packages:</p>
<ul>
<li><b>Prs3d</b> provides builders for simple geometric elements.<ul>
<li><code>Prs3d_Arrow</code>, <code>Prs3d_BndBox</code>, <code>Prs3d_Point</code>, <code>Prs3d_Text</code>, <code>Prs3d_ToolCylinder</code>, <code>Prs3d_ToolDisk</code>, <code>Prs3d_ToolSector</code>, <code>Prs3d_ToolSphere</code>, <code>Prs3d_ToolTorus</code> </li>
</ul>
</li>
<li><b>StdPrs</b> provides builders for analytical geometry and B-Rep shapes (<code>TopoDS_Shape</code>).<ul>
<li><code>StdPrs_WFShape</code>, <code>StdPrs_ShadedShape</code>, <code>StdPrs_BRepTextBuilder</code> </li>
</ul>
</li>
<li><b>DsgPrs</b> provides builders for datums, dimensions and relations.</li>
</ul>
<p>Presentation builders are reusable bricks for constructing <code>AIS</code> objects. Standard OCCT interactive objects highly rely on them, so that you may easily replicate <code>AIS_Shape</code> presentation for displaying a shape with just a couple of lines calling <code>StdPrs_ShadedShape:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (100.0, 100.0);</div>
<div class="line">  StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">theCtx-&gt;Display (aPrs, <span class="keyword">true</span>);</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step1_shaded.png" alt="" height="409px"/>
<div class="caption">
<code>StdPrs_ShadedShape</code> presentation builder.</div></div>
<p><code>PrsMgr_PresentableObject::Compute()</code> method takes three arguments:</p><ul>
<li><b>Presentation Manager</b> (<code>PrsMgr_PresentationManager</code>). Rarely used parameter, but might be necessary for some advanced use cases.</li>
<li><b>Presentation</b> (<code>Prs3d_Presentation</code> or <code>Graphic3d_Structure</code>). Defines the structure to fill in with presentation elements.</li>
<li><b>Display Mode</b> (integer number). Specifies the display mode to compute. <b>0</b> is a default display mode, if not overridden by <code>AIS_InteractiveObject::SetDisplayMode()</code> or by <code>AIS_InteractiveContext::Display()</code>.</li>
</ul>
<p>For each supported display mode, the <b>Presentation Manager</b> creates a dedicated <code>Prs3d_Presentation</code> and stores it within the object itself as a list of presentations <code>PrsMgr_PresentableObject::Presentations()</code>. It is a good practice to reject unsupported display modes within <code>::Compute()</code> method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (theMode != 0) { <span class="keywordflow">return</span>; } <span class="comment">// reject non-zero display modes</span></div>
<div class="line"> </div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (100.0, 100.0);</div>
<div class="line">  StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This wouldn't, however, prevent application from displaying the object with another display mode like this:</p>
<div class="fragment"><div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">theCtx-&gt;Display (aPrs, 100, -1, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>The code above will display <code>MyAisObject</code> with display mode equal to 100, and after <code>::Compute()</code> modifications nothing will be displayed on the screen. <code>AIS</code> will still create a presentation with specified display mode, but it will be empty - method <code>::AcceptDisplayMode()</code> could be overridden to disallow even creation of an empty presentation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyAisObject::AcceptDisplayMode (<span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> theMode == 0; <span class="comment">// reject non-zero display modes</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><code>AIS_InteractiveContext::Display()</code> checks if requested display mode is actually supported by the object, and uses default display mode (<em><b>0</b></em>) if it is not. <code>StdPrs_ShadedShape</code> prepares a shaded (triangulated) presentation of a shape, while <code>StdPrs_WFShape</code> creates a wireframe presentation with B-Rep wire boundaries:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!AcceptDisplayMode (theMode)) { <span class="keywordflow">return</span>; }</div>
<div class="line"> </div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (100.0, 100.0);</div>
<div class="line">  StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer); <span class="comment">// add shading</span></div>
<div class="line">  StdPrs_WFShape::Add     (thePrs, aShape, myDrawer); <span class="comment">// add wireframe</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step1_shaded_wf.png" alt="" height="409px"/>
<div class="caption">
Result of <code>StdPrs_ShadedShape</code> + <code>StdPrs_WFShape</code> presentation builders.</div></div>
<p>Presentation builders take the <code>Prs3d_Drawer</code> object defining various attributes - material of shaded shape, number of isolines in wireframe mode, tessellation quality, line colors and many others. <code>PrsMgr_PresentableObject</code> defines <code>myDrawer</code> property with default attributes. <code>StdPrs</code> makes it easy to display topological shapes. With the help of <code>Prs3d</code> tools we may display elements like arrows, boxes or text labels. Let's extend our presentation with a second <b>display mode 1</b> showing a bounding box using <code>Prs3d_BndBox</code> builder:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyAisObject::AcceptDisplayMode (<span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <span class="keywordflow">return</span> theMode == 0 || theMode == 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (100.0, 100.0);</div>
<div class="line">  <span class="keywordflow">if</span> (theMode == 0)</div>
<div class="line">  {</div>
<div class="line">    StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer);</div>
<div class="line">    StdPrs_WFShape::Add (thePrs, aShape, myDrawer); <span class="comment">// add wireframe</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theMode == 1)</div>
<div class="line">  {</div>
<div class="line">    Bnd_Box aBox;</div>
<div class="line">    BRepBndLib::Add (aShape, aBox);</div>
<div class="line">    Prs3d_BndBox::Add (thePrs, aBox, myDrawer);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, displaying an object with <b>display mode 1</b> will show a box:</p>
<div class="fragment"><div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">theCtx-&gt;Display (aPrs, 1, 0, <span class="keyword">true</span>);</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step1_bndbox.png" alt="" height="409px"/>
<div class="caption">
<code>Prs3d_BndBox</code> presentation builder.</div></div>
<p><code>AIS</code> disallows activating multiple display modes at the same time, so that these presentation modes should be alternatives to each other. But <code>AIS</code> may use non-active display mode for highlighting purposes - like wireframe (<code>AIS_Wireframe</code>) presentation displayed on top of shaded (<code>AIS_Shaded</code>) presentation for selected <code>AIS_Shape</code> objects.</p>
<p>Let's define a dedicated enumeration for display modes supported by our interactive object and setup the 1st (<code>MyDispMode_Highlight</code>) display mode for highlighting with help of <code>PrsMgr_PresentableObject::SetHilightMode()</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisObject : <span class="keyword">public</span> AIS_InteractiveObject</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> MyDispMode { MyDispMode_Main = 0, MyDispMode_Highlight = 1 };</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">MyAisObject::MyAisObject()</div>
<div class="line">{</div>
<div class="line">  SetDisplayMode (MyDispMode_Main);      <span class="comment">// main (active) display mode</span></div>
<div class="line">  SetHilightMode (MyDispMode_Highlight); <span class="comment">// auxiliary (highlighting) mode</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">theCtx-&gt;Display (aPrs, MyAisObject::MyDispMode_Main, 0, <span class="keyword">false</span>);</div>
<div class="line">theCtx-&gt;HilightWithColor (aPrs, aPrs-&gt;HilightAttributes(), <span class="keyword">false</span>);</div>
<div class="line">theCtx-&gt;CurrentViewer()-&gt;Redraw();</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step1_highlight.png" alt="" height="409px"/>
<div class="caption">
Highlighting by color (left) and highlighting by another display mode (right).</div></div>
<p>In this particular use case we've used the method <code>AIS_InteractiveContext::HilightWithColor()</code> instead of <code>::SetSelected()</code> - just because our object is not selectable yet and <code>::SetSelected()</code> wouldn't work. Highlighted presentation appears on the screen with modulated color (see left screenshot above). Using a dedicated display mode for highlighting (right screenshot above) allows customizing presentation in selected / highlighted states.</p>
<h1><a class="anchor" id="prim_arrays"></a>
Primitive arrays</h1>
<p><code>Prs3d_Presentation</code> might be filled in by the following <b>primitives</b>:</p><ul>
<li><b>Triangles</b><ul>
<li><code>Graphic3d_ArrayOfTriangles</code> </li>
<li><code>Graphic3d_ArrayOfTriangleFans</code> </li>
<li><code>Graphic3d_ArrayOfTriangleStrips</code> </li>
</ul>
</li>
<li><b>Lines</b><ul>
<li><code>Graphic3d_ArrayOfSegments</code> </li>
<li><code>Graphic3d_ArrayOfPolylines</code> </li>
</ul>
</li>
<li><b>Points</b> or <b>Markers</b><ul>
<li><code>Graphic3d_ArrayOfPoints</code> </li>
</ul>
</li>
</ul>
<p>This triplet of primitives is what graphics hardware is capable of rendering, so that it could be transferred directly to low-level graphics libraries in the form of <em>Vertex Buffer Objects</em> (VBO). Each <b>primitive array</b> consists of an array of vertex attributes (<em><b>position</b>, <b>normal</b>, <b>texture coordinates</b>, <b>vertex colors</b></em>, etc.) and optional <b>array of indices</b>. The latter one avoids duplicating vertices shared between connected elements (triangles, polylines) in attributes array.</p>
<p><code>Graphic3d_ArrayOfPrimitives</code> and it's subclasses provide a convenient interface for filling in primitive arrays:</p><ul>
<li>Constructor takes a number of vertices, number of edges (indices) and a bitmask of optional vertex attributes.</li>
<li><code>Graphic3d_ArrayOfPrimitives::AddVertex()</code> appends a vertex with specified attributes to the end of the array (within the range specified at construction time).</li>
<li><code>Graphic3d_ArrayOfPrimitives::AddEdges()</code> appends indices, starting with 1. Each line segment is defined by two consequential edges, each triangle is defined by three consequential edges.</li>
</ul>
<p>Let's extend our sample and display a cylinder section contour defined by array of indexed segments (e.g. a polyline of four vertices):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (aRadius, aHeight);</div>
<div class="line">  <span class="keywordflow">if</span> (theMode == MyDispMode_Main)</div>
<div class="line">  {</div>
<div class="line">    StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer);</div>
<div class="line">    <span class="comment">//StdPrs_WFShape::Add (thePrs, aShape, myDrawer);</span></div>
<div class="line">    Handle(Graphic3d_ArrayOfSegments) aSegs = <span class="keyword">new</span> Graphic3d_ArrayOfSegments (4, 4 * 2, Graphic3d_ArrayFlags_None);</div>
<div class="line">    aSegs-&gt;AddVertex (gp_Pnt (0.0, -aRadius, 0.0));</div>
<div class="line">    aSegs-&gt;AddVertex (gp_Pnt (0.0, -aRadius, aHeight));</div>
<div class="line">    aSegs-&gt;AddVertex (gp_Pnt (0.0,  aRadius, aHeight));</div>
<div class="line">    aSegs-&gt;AddVertex (gp_Pnt (0.0,  aRadius, 0.0));</div>
<div class="line">    aSegs-&gt;AddEdges (1, 2);</div>
<div class="line">    aSegs-&gt;AddEdges (2, 3);</div>
<div class="line">    aSegs-&gt;AddEdges (3, 4);</div>
<div class="line">    aSegs-&gt;AddEdges (4, 1);</div>
<div class="line">    Handle(Graphic3d_Group) aGroupSegs = thePrs-&gt;NewGroup();</div>
<div class="line">    aGroupSegs-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;WireAspect()-&gt;Aspect());</div>
<div class="line">    aGroupSegs-&gt;AddPrimitiveArray (aSegs);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theMode == MyDispMode_Highlight) { ... }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step2_segments.png" alt="" height="409px"/>
<div class="caption">
Displaying <code>Graphic3d_ArrayOfSegments</code>.</div></div>
<p>The process is quite straightforward:</p><ul>
<li>Create a new <code>Graphic3d_Group</code> using <code>Prs3d_Presentation::NewGroup()</code>;</li>
<li>Specify presentation aspects using <code>Graphic3d_Group::SetGroupPrimitivesAspect()</code>;</li>
<li>Create and add an array of primitives using <code>Graphic3d_Group::AddPrimitiveArray()</code>.</li>
</ul>
<p>Standard presentation builders like <code>StdPrs_ShadedShape</code> / <code>StdPrs_WFShape</code> internally do exactly the same thing - a tessellated representation of a shape is added to presentation in form of triangles (shaded), line segments (wireframe and free edges) and markers (free shape vertices).</p>
<p>A single <code>Graphic3d_Group</code> normally defines just a single primitive array, but it is technically possible adding more arrays to the same group <code>Graphic3d_Group::AddPrimitiveArray()</code> and with different aspects <code>Graphic3d_Group::SetPrimitivesAspect()</code>, which might be considered in advanced scenarios.</p>
<p>Method <code>Graphic3d_Group::AddText()</code> allows adding text labels to a presentation. Internally, text labels are rendered as an array of textured triangles using texture atlas created from a font, but this complex logic is hidden from the user.</p>
<h1><a class="anchor" id="prim_aspects"></a>
Primitive aspects</h1>
<p><code>Graphic3d_Aspects</code> is a class defining <b>display properties</b> of a primitive array (<code>Graphic3d_Group::SetGroupPrimitivesAspect()</code>) - <em><b>material</b>, <b>shading model</b>, <b>color</b>, <b>texture maps</b>, <b>blending mode</b>, <b>line width</b></em> and others.</p>
<p>There are also subclasses <code>Graphic3d_AspectFillArea3d</code> (triangles), <code>Graphic3d_AspectLine3d</code> (lines), <code>Graphic3d_AspectMarker3d</code> (markers) and <code>Graphic3d_AspectText3d</code> (text labels) defined as specializations for a specific primitive array type. These subclasses exist for historical reasons and are treated by renderers in exactly the same way.</p>
<p>It is technically possible to create transient aspects directly within <code>::Compute()</code> method like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  Handle(Graphic3d_Aspects) anAspects = <span class="keyword">new</span> Graphic3d_Aspects();</div>
<div class="line">  anAspects-&gt;SetShadingModel (Graphic3d_TypeOfShadingModel_Unlit);</div>
<div class="line">  anAspects-&gt;SetColor (Quantity_NOC_RED);</div>
<div class="line">  Handle(Graphic3d_Group) aGroup = thePrs-&gt;NewGroup();</div>
<div class="line">  aGroup-&gt;SetGroupPrimitivesAspect (anAspects);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>While this code would work as expected, but prevents further dynamic updates of presentation aspects without recomputing entire presentation. Instead, it is preferred taking attributes from <code>PrsMgr_PresentableObject::myDrawer</code> / <code>::Attributes()</code> or storing custom attributes as class fields. <code>Prs3d_Drawer</code> defines a set of attributes used by <code>AIS</code> presentation builders, but the same parameters might be used by a custom builder as well.</p>
<p>It is also preferred preallocating attributes in the class constructor. This would allow changing attributes without recomputing the entire presentation - just by calling <code>PrsMgr_PresentableObject::SynchronizeAspects()</code> after modifications. Our custom object uses <code>myDrawer-&gt;ShadingAspect()</code> and <code>myDrawer-&gt;WireAspect()</code> aspects, so let's initialize them explicitly - assign silver material for shading and green color to line segments:</p>
<div class="fragment"><div class="line">MyAisObject::MyAisObject()</div>
<div class="line">{</div>
<div class="line">  SetHilightMode (MyDispMode_Highlight);</div>
<div class="line">  myDrawer-&gt;SetupOwnShadingAspect();</div>
<div class="line">  myDrawer-&gt;ShadingAspect()-&gt;SetMaterial (Graphic3d_NameOfMaterial_Silver);</div>
<div class="line">  myDrawer-&gt;SetWireAspect (<span class="keyword">new</span> Prs3d_LineAspect (Quantity_NOC_GREEN, Aspect_TOL_SOLID, 2.0));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="quadric_builders"></a>
Quadric builders</h1>
<p>Previously, we've used <code>StdPrs_ShadedShape</code> for displaying cylinder geometry. The <code>Prs3d</code> package provides a simpler way for displaying geometry like cylinders, spheres and toruses - based on the <code>Prs3d_ToolQuadric</code> interface. This interface allows bypassing creation of a complex B-Rep (<code>TopoDS_Shape</code>) definition of a simple geometry, and to avoid using general-purpose tessellators like <code>BRepMesh</code>.</p>
<blockquote class="doxtable">
<p>This difference could be negligible for a small number of such objects, but might become considerable for larger amounts. The B-Rep definition of a valid cylinder includes 2 unique <code>TopoDS_Vertex</code>, 3 <code>TopoDS_Edge</code>, 3 <code>TopoDS_Wire</code>, 3 <code>TopoDS_Face</code>, 1 <code>TopoDS_Shell</code> and 1 <code>TopoDS_Solid</code>. Internally each <code>TopoDS_Edge</code> also defines curves (<code>Geom_Curve</code> as well as 2D parametric <code>Geom2d_Curve</code>) and each <code>TopoDS_Face</code> defines analytical surface (<code>Geom_Surface</code>). Meshing such geometry with the help of <code>BRepMesh</code> is much more complicated than one may think. A plenty of data structures (memory!) and computations (time!) for displaying a geometry that could be triangulated by a simple for loop. </p>
</blockquote>
<p><code>Prs3d_ToolQuadric</code> solves this problem by creating a triangulation for such kinds of shapes in a straight-forward way. Let's try using <code>Prs3d_ToolCylinder</code> in our sample:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (aRadius, aHeight);</div>
<div class="line">  <span class="keywordflow">if</span> (theMode == MyDispMode_Main)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//StdPrs_ShadedShape::Add (thePrs, aShape, myDrawer); // add shading</span></div>
<div class="line">    <span class="comment">//StdPrs_WFShape::Add (thePrs, aShape, myDrawer); // add wireframe</span></div>
<div class="line">    Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">     Prs3d_ToolCylinder::Create (aRadius, aRadius, aHeight, 10, 10, gp_Trsf());</div>
<div class="line">    Handle(Graphic3d_Group) aGroupTris = thePrs-&gt;NewGroup();</div>
<div class="line">    aGroupTris-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;ShadingAspect()-&gt;Aspect());</div>
<div class="line">    aGroupTris-&gt;AddPrimitiveArray (aTris);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step3_quadrics_10.png" alt="" height="409px"/>
<div class="caption">
<code>Prs3d_ToolCylinder</code> (10 slices).</div></div>
<p>Well... that looks a little bit edgy. Quadric builder creates a triangulation taking the following parameters:</p><ul>
<li>Geometry parameters. (in case of a cylinder - base radius, top radius and height).</li>
<li>Number of subdivisions along U (slices) and V (stacks) parameters. In some cases only one parametric scope matters.</li>
<li>Transformation <code>gp_Trsf</code> to apply (original geometry is defined within some reference coordinate system).</li>
</ul>
<p>Let's increase number of subdivisions from <em>10</em> to <em>25</em>: </p><div class="fragment"><div class="line">Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">  Prs3d_ToolCylinder::Create (aRadius, aRadius, aHeight, 25, 25, gp_Trsf());</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step3_quadrics_25.png" alt="" height="409px"/>
<div class="caption">
<code>Prs3d_ToolCylinder</code> (25 slices).</div></div>
<p>It looks much better now! Note that <code>Prs3d_ToolCylinder</code> could be used for building both cones and cylinders depending on top/bottom radius definition.</p>
<p>There is one issue though - our cylinder doesn't have top and bottom anymore! To fix this problem we will use one more quadric builder <code>Prs3d_ToolDisk:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  <span class="keywordflow">if</span> (theMode == MyDispMode_Main)</div>
<div class="line">  {</div>
<div class="line">    Prs3d_ToolCylinder aCyl (aRadius, aRadius, aHeight, 25, 25);</div>
<div class="line">    Prs3d_ToolDisk aDisk (0.0, aRadius, 25, 1);</div>
<div class="line"> </div>
<div class="line">    Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">      <span class="keyword">new</span> Graphic3d_ArrayOfTriangles (aCyl.VerticesNb() + 2 * aDisk.VerticesNb(),</div>
<div class="line">                                      3 * (aCyl.TrianglesNb() + 2 * aDisk.TrianglesNb()),</div>
<div class="line">                                      Graphic3d_ArrayFlags_VertexNormal);</div>
<div class="line">    aCyl .FillArray (aTris, gp_Trsf());</div>
<div class="line">    aDisk.FillArray (aTris, gp_Trsf());</div>
<div class="line"> </div>
<div class="line">    gp_Trsf aDisk2Trsf;</div>
<div class="line">    aDisk2Trsf.SetTransformation (gp_Ax3 (gp_Pnt (0.0, 0.0, aHeight), -gp::DZ(), gp::DX()), gp::XOY());</div>
<div class="line">    aDisk.FillArray (aTris, aDisk2Trsf);</div>
<div class="line"> </div>
<div class="line">    Handle(Graphic3d_Group) aGroupTris = thePrs-&gt;NewGroup();</div>
<div class="line">    aGroupTris-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;ShadingAspect()-&gt;Aspect());</div>
<div class="line">    aGroupTris-&gt;AddPrimitiveArray (aTris);</div>
<div class="line">    aGroupTris-&gt;SetClosed (<span class="keyword">true</span>);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now our cylinder looks solid! The sample above merges two triangulations into a single one instead of appending each primitive array individually.</p>
<p>This looks like a minor difference, but it might have a <em>dramatic impact on performance</em> in case of a large scene, as each <code>Graphic3d_ArrayOfPrimitives</code> is mapped into a dedicated draw call at graphic driver (OpenGL) level.</p>
<div class="image">
<img src="ais_object_step3_quadrics_fin.png" alt="" height="409px"/>
<div class="caption">
<code>Prs3d_ToolCylinder</code> + <code>Prs3d_ToolDisk</code>.</div></div>
<p>As an exercise, let's try computing a triangulation for cylinder disk without help of <code>Prs3d_ToolDisk</code> builder:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::Compute (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                           <span class="keyword">const</span> Handle(Prs3d_Presentation)&amp; thePrs,</div>
<div class="line">                           <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  <span class="keywordflow">if</span> (theMode == MyDispMode_Main)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> aNbSlices = 25;</div>
<div class="line">    Prs3d_ToolCylinder aCyl (aRadius, aRadius, aHeight, aNbSlices, aNbSlices);</div>
<div class="line">    Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">      <span class="keyword">new</span> Graphic3d_ArrayOfTriangles (aCyl.VerticesNb(),</div>
<div class="line">                                      3 * (aCyl.TrianglesNb()),</div>
<div class="line">                                      Graphic3d_ArrayFlags_VertexNormal);</div>
<div class="line">    aCyl.FillArray (aTris, gp_Trsf());</div>
<div class="line"> </div>
<div class="line">    Handle(Graphic3d_ArrayOfTriangles) aTris2 =</div>
<div class="line">      <span class="keyword">new</span> Graphic3d_ArrayOfTriangles (aNbSlices + 1, aNbSlices * 3, Graphic3d_ArrayFlags_VertexNormal);</div>
<div class="line">    aTris2-&gt;AddVertex (gp_Pnt (0.0, 0.0, aHeight), -gp::DZ());</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> aSliceIter = 0; aSliceIter &lt; aNbSlices; ++aSliceIter)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> anAngle = M_PI * 2.0 * double(aSliceIter) / double(aNbSlices);</div>
<div class="line">      aTris2-&gt;AddVertex (gp_Pnt (Cos (anAngle) * aRadius, Sin (anAngle) * aRadius, aHeight), -gp::DZ());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> aSliceIter = 0; aSliceIter &lt; aNbSlices; ++aSliceIter)</div>
<div class="line">    {</div>
<div class="line">      aTris2-&gt;AddEdges (1, aSliceIter + 2, aSliceIter + 1 &lt; aNbSlices ? (aSliceIter + 3) : 2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Handle(Graphic3d_Group) aGroupTris = thePrs-&gt;NewGroup();</div>
<div class="line">    aGroupTris-&gt;SetGroupPrimitivesAspect (myDrawer-&gt;ShadingAspect()-&gt;Aspect());</div>
<div class="line">    aGroupTris-&gt;AddPrimitiveArray (aTris);</div>
<div class="line">    aGroupTris-&gt;AddPrimitiveArray (aTris2);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step3_quadrics_disk.png" alt="" height="409px"/>
<div class="caption">
Manually triangulated disk.</div></div>
<p>The disk is here, but it has a strange color - like it is not affected by lighting. This happens when vertex normals are defined incorrectly. In our case we defined disk normal as <code>-DZ</code> (see the second argument of <code>Graphic3d_ArrayOfTriangles::AddVertex()</code>), but normal direction should be also aligned to triangulation winding rule. Graphic driver defines the front side of triangle using clockwise order of triangle nodes, and normal should be defined for a front side of triangle - e.g. it should be <code>gp::DZ()</code> in our case. After reversing vertex normal direction, cylinder looks exactly like when <code>Prs3d_ToolDisk</code> was used.</p>
<p>Front / back face orientation might be displayed using different material based on <code>Graphic3d_Aspects::SetDistinguish()</code> flag and <code>::FrontMaterial()</code> / <code>::BackMaterial()</code> setup.</p>
<h1><a class="anchor" id="ais_selection"></a>
Computing selection</h1>
<p>In the first part of the tutorial we have created a custom <code>AIS</code> object <code>MyAisObject</code> computing presentation by implementing the <code>PrsMgr_PresentableObject::Compute()</code> interface. In this part we will extend our object with interactive capabilities and make it selectable through implementing <code>SelectMgr_SelectableObject</code> interface.</p>
<p>Let's do the first step and put into <code>::ComputeSelection()</code> method some logic. This method should fill in the <code>SelectMgr_Selection</code> argument with <code>SelectMgr_SensitiveEntity</code> entities defining selectable elements - triangulations, polylines, points and their composition. <code>Select3D_SensitiveBox</code> is probably the simplest way to define selectable volume - by it's bounding box:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                    <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (aRadius, aHeight);</div>
<div class="line">  Bnd_Box aBox;</div>
<div class="line">  BRepBndLib::Add (aShape, aBox);</div>
<div class="line">  Handle(SelectMgr_EntityOwner) anOwner = <span class="keyword">new</span> SelectMgr_EntityOwner (<span class="keyword">this</span>);</div>
<div class="line">  Handle(Select3D_SensitiveBox) aSensBox = <span class="keyword">new</span> Select3D_SensitiveBox (anOwner, aBox);</div>
<div class="line">  theSel-&gt;Add (aSensBox);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>SelectMgr_EntityOwner</code> is a key object in selection logic - it serves as an identifier of a pickable object or it's part. You may see this object in methods like <code>AIS_InteractiveContext::DetectedOwner()</code>, <b>Owners</b> are stored within the list of selection objects <code>AIS_Selection</code> and it received by methods like <code>AIS_InteractiveContext::SetSelected()</code> and <code>AIS_InteractiveContext::AddOrRemoveSelected()</code>. From the Selector's point of view, <code>AIS_InteractiveObject</code> is just a drawer for <code>SelectMgr_EntityOwner</code>.</p>
<p>The <em><b>0th selection mode</b></em> normally defines a single Owner of the entire object. To make a composite object selectable as whole, we add to Selection as many SensitiveEntity as necessary referring to the same Owner. It might look confusing from first glance, that <code>SelectMgr_SensitiveEntity</code> stores <code>SelectMgr_EntityOwner</code> as a class field, and not in the opposite way (<code>SelectMgr_EntityOwner</code> doesn't store the list of <code>SelectMgr_SensitiveEntity</code> defining it's picking volume).</p>
<p>For local selection (selection of object parts) we create individual Owners for each part and add SensitiveEntity to Selection in the same way. Owner may store an additional identifier as a class field, like <code>StdSelect_BRepOwner</code> stores <code>TopoDS_Shape</code> as an identifier of picked sub-shape with <code>AIS_Shape</code> object.</p>
<p>In a similar way as <code>StdPrs_ShadedShape</code> is a <b>presentation builder</b> for <code>TopoDS_Shape</code>, the <code>StdSelect_BRepSelectionTool</code> can be seen as a standard <b>selection builder</b> for shapes:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                    <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  TopoDS_Shape aShape = BRepPrimAPI_MakeCylinder (aRadius, aHeight);</div>
<div class="line">  Standard_Real aDefl = StdPrs_ToolTriangulatedShape::GetDeflection (aShape, myDrawer);</div>
<div class="line">  StdSelect_BRepSelectionTool::Load (theSel, <span class="keyword">this</span>, aShape, TopAbs_SHAPE, aDefl,</div>
<div class="line">                                     myDrawer-&gt;DeviationAngle(),</div>
<div class="line">                                     myDrawer-&gt;IsAutoTriangulation());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Internally, <code>StdSelect_BRepSelectionTool</code> iterates over sub-shapes and appends to the Selection (<code>theSel</code>) entities like <code>Select3D_SensitiveTriangulation</code> (for faces) and <code>Select3D_SensitiveCurve</code> (for edges).</p>
<p>Previously, we have used <code>Prs3d_ToolCylinder</code> to triangulate a cylinder, so let's try to construct <code>Select3D_SensitivePrimitiveArray</code> from the same triangulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                    <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  Handle(SelectMgr_EntityOwner) anOwner = <span class="keyword">new</span> SelectMgr_EntityOwner (<span class="keyword">this</span>);</div>
<div class="line">  Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">    Prs3d_ToolCylinder::Create (aRadius, aRadius, aHeight, 25, 25, gp_Trsf());</div>
<div class="line">  Handle(Select3D_SensitivePrimitiveArray) aSensTri =</div>
<div class="line">    <span class="keyword">new</span> Select3D_SensitivePrimitiveArray (anOwner);</div>
<div class="line">  aSensTri-&gt;InitTriangulation (aTris-&gt;Attributes(), aTris-&gt;Indices(),</div>
<div class="line">                               TopLoc_Location());</div>
<div class="line">  theSel-&gt;Add (aSensTri);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Selection is computed independently from presentation, so that they don't have to match each other. But inconsistency between presentation and selection might confuse a user, when he will not be able to pick an object clearly displayed under the mouse cursor. These issues might happen, for example, when selection uses tessellated representation of the same geometry computed with different parameters (different number of subdivisions, or different deflection parameters).</p>
<p>As in case of <code>::Compute()</code>, it makes sense defining some enumeration of <b>selection modes</b> supported by specific object and reject unsupported ones to avoid unexpected behavior:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisObject::ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                    <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (theMode != 0) { <span class="keywordflow">return</span>; }</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Unlike display modes, <code>AIS_InteractiveContext</code> allows activating an arbitrary combination of selection modes. A user should be careful to activate only the modes that actually make sense and may work together.</p>
<p>Selection mode to activate could be specified while displaying the object (passing <em><b>-1</b></em> instead of <em><b>0</b></em> would display an object with deactivated selection):</p>
<div class="fragment"><div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">theCtx-&gt;Display (aPrs, MyAisObject::MyDispMode_Main, 0, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>Later on <code>AIS_InteractiveContext::SetSelectionModeActive()</code>, or it's wrappers <code>AIS_InteractiveContext::Activate()</code> and <code>AIS_InteractiveContext::Deactivate()</code>, could be used to enable or disable desired selection modes one by one.</p>
<h1><a class="anchor" id="sel_owner_highlight"></a>
Highlighting selection owner</h1>
<p>As has been mentioned in the previous section, <code>SelectMgr_EntityOwner</code> is a key object which can be used as an identifier of selectable part(s). Naturally, you might want to subclass it to put some application-specific ids for identification of selected parts. But there are more things you may do with the Owner class like customized highlighting.</p>
<p>Let's start from the beginning and define a custom Owner class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisOwner : <span class="keyword">public</span> SelectMgr_EntityOwner</div>
<div class="line">{</div>
<div class="line">  DEFINE_STANDARD_RTTI_INLINE(MyAisOwner, SelectMgr_EntityOwner)</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyAisOwner (<span class="keyword">const</span> Handle(MyAisObject)&amp; theObj, <span class="keywordtype">int</span> thePriority = 0)</div>
<div class="line">  : SelectMgr_EntityOwner (theObj, thePriority) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> HilightWithColor (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                                 <span class="keyword">const</span> Handle(Prs3d_Drawer)&amp; theStyle,</div>
<div class="line">                                 <span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{ base_type::HilightWithColor (thePrsMgr, theStyle, theMode); }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Unhilight (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                          <span class="keyword">const</span> Standard_Integer theMode)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">  </span>{ base_type::Unhilight  (thePrsMgr, theMode); }</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  Handle(Prs3d_Presentation) myPrs;</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>SelectMgr_EntityOwner</code> doesn't define any pure virtual methods, and can be instanced straight ahead, like it was done within <code>MyAisObject::ComputeSelection()</code> implementation above. Let's revert usage of a dedicated display mode for highlighting (remove <code>SetHilightMode()</code> in <code>MyAisObject</code> constructor) and use our new class <code>MyAisOwner</code> within <code>::ComputeSelection()</code>:</p>
<div class="fragment"><div class="line">MyAisObject::MyAisObject()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//SetHilightMode (MyDispMode_Highlight);</span></div>
<div class="line">  myDrawer-&gt;SetupOwnShadingAspect();</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyAisObject::ComputeSelection (<span class="keyword">const</span> Handle(SelectMgr_Selection)&amp; theSel,</div>
<div class="line">                                    <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> aRadius = 100.0, aHeight = 100.0;</div>
<div class="line">  Handle(MyAisOwner) anOwner = <span class="keyword">new</span> MyAisOwner (<span class="keyword">this</span>);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The further logic creating sensitive entities and filling in Selection could be left as is. Substitution of <code>SelectMgr_EntityOwner</code> with <code>MyAisOwner</code> currently doesn't change behavior and we see highlighting of the entire object through color modulation. This is because default implementation of <code>SelectMgr_EntityOwner</code> for highlighting logic looks like this (simplified):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> SelectMgr_EntityOwner::HilightWithColor (</div>
<div class="line">  <span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">  <span class="keyword">const</span> Handle(Prs3d_Drawer)&amp; theStyle,</div>
<div class="line">  <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> Graphic3d_ZLayerId aHiLayer =</div>
<div class="line">      theStyle-&gt;ZLayer() != Graphic3d_ZLayerId_UNKNOWN</div>
<div class="line">    ? theStyle-&gt;ZLayer()</div>
<div class="line">    : mySelectable-&gt;ZLayer();</div>
<div class="line">  thePrsMgr-&gt;Color (mySelectable, theStyle, theMode, NULL, aHiLayer);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="ais_object_step4_highlight1.png" alt="" height="409px"/>
<div class="caption">
Default behavior of <code>SelectMgr_EntityOwner::HilightWithColor</code>().</div></div>
<p>Now, let's override the <code>SelectMgr_EntityOwner::HilightWithColor()</code> method and display a bounding box presentation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisOwner::HilightWithColor (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                                   <span class="keyword">const</span> Handle(Prs3d_Drawer)&amp; theStyle,</div>
<div class="line">                                   <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (myPrs.IsNull())</div>
<div class="line">  {</div>
<div class="line">    myPrs = <span class="keyword">new</span> Prs3d_Presentation (thePrsMgr-&gt;StructureManager());</div>
<div class="line">    MyAisObject* anObj = <span class="keyword">dynamic_cast&lt;</span>MyAisObject*<span class="keyword">&gt;</span> (mySelectable);</div>
<div class="line">    anObj-&gt;Compute (thePrsMgr, myPrs, MyAisObject::MyDispMode_Highlight);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!thePrsMgr-&gt;IsImmediateModeOn())</div>
<div class="line">  {</div>
<div class="line">    myPrs-&gt;Display();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>SelectMgr_EntityOwner::HilightWithColor()</code> doesn't receive a presentation to fill in as an argument; highlight presentation should be manually created and even explicitly displayed on the screen. To avoid code duplication, the code above reuses <code>MyAisObject::Compute()</code> already implementing computation of highlight presentation.</p>
<div class="image">
<img src="ais_object_step4_highlight2.png" alt="" height="409px"/>
<div class="caption">
Result of custom implementation <code>MyAisOwner::HilightWithColor</code>().</div></div>
<p>The visual result of the selected object looks exactly the same as when we've used a dedicated highlight mode. One thing became broken, though - highlighting remains displayed even after clearing selection. To fix this issue, we need implementing <code>SelectMgr_EntityOwner::Unhilight()</code> and hide our custom presentation explicitly:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisOwner::Unhilight (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                            <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!myPrs.IsNull()) { myPrs-&gt;Erase(); }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another problem is that the object is no longer dynamically highlighted. To fix that we need to handle <code>PrsMgr_PresentationManager::IsImmediateModeOn()</code> specifically. Within this mode turned ON, presentation should be displayed on the screen with help of <code>PrsMgr_PresentationManager::AddToImmediateList()</code> method (it will be cleared from the screen automatically on the next mouse movement):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisOwner::HilightWithColor (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                                   <span class="keyword">const</span> Handle(Prs3d_Drawer)&amp; theStyle,</div>
<div class="line">                                   <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (myPrs.IsNull())</div>
<div class="line">  {</div>
<div class="line">    myPrs = <span class="keyword">new</span> Prs3d_Presentation (thePrsMgr-&gt;StructureManager());</div>
<div class="line">    MyAisObject* anObj = <span class="keyword">dynamic_cast&lt;</span>MyAisObject*<span class="keyword">&gt;</span> (mySelectable);</div>
<div class="line">    anObj-&gt;Compute (thePrsMgr, myPrs, MyAisObject::MyDispMode_Highlight);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (thePrsMgr-&gt;IsImmediateModeOn())</div>
<div class="line">  {</div>
<div class="line">    Handle(Prs3d_PresentationShadow) aShadow =</div>
<div class="line">      <span class="keyword">new</span> Prs3d_PresentationShadow (thePrsMgr-&gt;StructureManager(), myPrs);</div>
<div class="line">    aShadow-&gt;SetZLayer (Graphic3d_ZLayerId_Top);</div>
<div class="line">    aShadow-&gt;Highlight (theStyle);</div>
<div class="line">    thePrsMgr-&gt;AddToImmediateList (aShadow);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    myPrs-&gt;Display();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We may create two dedicated presentations for dynamic highlighting or reuse existing one for both cases with help of a transient object <code>Prs3d_PresentationShadow</code>.</p>
<p>Let's go further and make dynamic highlighting a little bit more interesting - by drawing a surface normal at the point where mouse picked the object:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAisOwner::HilightWithColor (<span class="keyword">const</span> Handle(PrsMgr_PresentationManager)&amp; thePrsMgr,</div>
<div class="line">                                   <span class="keyword">const</span> Handle(Prs3d_Drawer)&amp; theStyle,</div>
<div class="line">                                   <span class="keyword">const</span> Standard_Integer theMode)</div>
<div class="line">{</div>
<div class="line">  MyAisObject* anObj = <span class="keyword">dynamic_cast&lt;</span>MyAisObject*<span class="keyword">&gt;</span> (mySelectable);</div>
<div class="line">  <span class="keywordflow">if</span> (thePrsMgr-&gt;IsImmediateModeOn())</div>
<div class="line">  {</div>
<div class="line">    Handle(StdSelect_ViewerSelector) aSelector =</div>
<div class="line">      anObj-&gt;InteractiveContext()-&gt;MainSelector();</div>
<div class="line">    SelectMgr_SortCriterion aPickPnt;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> aPickIter = 1; aPickIter &lt;= aSelector-&gt;NbPicked(); ++aPickIter)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (aSelector-&gt;Picked (aPickIter) == <span class="keyword">this</span>)</div>
<div class="line">      {</div>
<div class="line">        aPickPnt = aSelector-&gt;PickedData (aPickIter);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Handle(Prs3d_Presentation) aPrs = mySelectable-&gt;GetHilightPresentation (thePrsMgr);</div>
<div class="line">    aPrs-&gt;SetZLayer (Graphic3d_ZLayerId_Top);</div>
<div class="line">    aPrs-&gt;Clear();</div>
<div class="line">    Handle(Graphic3d_Group) aGroup = aPrs-&gt;NewGroup();</div>
<div class="line">    aGroupPnt-&gt;SetGroupPrimitivesAspect (theStyle-&gt;ArrowAspect()-&gt;Aspect());</div>
<div class="line">    gp_Trsf aTrsfInv = mySelectable-&gt;LocalTransformation().Inverted();</div>
<div class="line">    gp_Dir  aNorm (aPickPnt.Normal.x(), aPickPnt.Normal.y(), aPickPnt.Normal.z());</div>
<div class="line">    Handle(Graphic3d_ArrayOfTriangles) aTris =</div>
<div class="line">      Prs3d_Arrow::DrawShaded (gp_Ax1(aPickPnt.Point, aNorm).Transformed (aTrsfInv),</div>
<div class="line">        1.0, 15.0,</div>
<div class="line">        3.0, 4.0, 10);</div>
<div class="line">    aGroupPnt-&gt;AddPrimitiveArray (aTris);</div>
<div class="line">    thePrsMgr-&gt;AddToImmediateList (aPrs);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Code above does not store our new highlight presentation as a property of <code>MyAisOwner</code>, and instead uses <code>SelectMgr_SelectableObject::GetHilightPresentation()</code> method to create a presentation stored directly inside of our interactive object.</p>
<p>Next trick is passing through the last picking results in <code>StdSelect_ViewerSelector</code>. Dynamic highlighting is expected to be called right after picking, so that highlighted Owner should be always found in picking results. <code>StdSelect_ViewerSelector::Picked()</code> returns entities in the descending order of their distance from picking ray origin (mouse cursor); normally our Owner should be the very first one in this list when no selection filters are assigned to <code>AIS_InteractiveContext</code>.</p>
<p><code>SelectMgr_SortCriterion</code> provides us useful information like 3D point on detected object lying on the picking ray, and surface normal direction at this point (actually, it would be a normal to a picked triangle), which we display as an arrow with help of <code>Prs3d_Arrow</code> presentation builder.</p>
<div class="image">
<img src="ais_object_step4_highlight3.png" alt="" height="409px"/>
<div class="caption">
Surface normal on mouse over.</div></div>
<p>Result looks pretty nice on the screenshot, but has interaction problems - once displayed, an arrow is no longer updated with further mouse movements. But this behavior is not a bug - <code>AIS</code> calls <code>MyAisOwner::HilightWithColor()</code> only when picking Owner changes to avoid unnecessary Viewer updates. To override this behavior, we may override <code>SelectMgr_EntityOwner::IsForcedHilight()</code> option:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisOwner : <span class="keyword">public</span> SelectMgr_EntityOwner</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> IsForcedHilight()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This solves the problem within our specific use case. Keep in mind that most objects don't need updating highlight presentation on every mouse move; overriding this flag everywhere would be a waste of resources and may cause performance issues - use it sparingly.</p>
<h1><a class="anchor" id="highlight_apporaches"></a>
Highlighting approaches</h1>
<p><code>AIS</code> provides one more alternative to handle presentation highlighting, which is managed by option <code>SelectMgr_SelectableObject::IsAutoHilight()</code>. By default, this option is turned ON and redirects highlighting logic to <code>SelectMgr_EntityOwner::HilightWithColor()</code> demonstrated in the previous section. Turning this option OFF redirects highlighting logic to the interactive object itself <code>SelectMgr_SelectableObject::HilightSelected()</code>.</p>
<p>Apart from moving the logic from Owner to Interactive Object, this approach allows handling highlighting of all selected Owners within the same Object at once and sharing a common presentation instead of per-Owner presentation - improving performance and reducing memory utilization in case of a large number of small selectable elements, like mesh nodes in <code>MeshVS_Mesh</code> object.</p>
<p>The further optimization of such a scenario would be using a single Owner for the entire Object storing the list of selected elements within the Owner itself - as utilized by <code>AIS_PointCloud</code> object for highlighting individual points.</p>
<p>We wouldn't describe these advanced techniques here in detail - let's just summarize main highlighting approaches available in <code>AIS:</code> </p><ul>
<li>Highlighting of a main presentation of Interactive Object (active display mode) filled in by <code>PrsMgr_PresentableObject::Compute()</code> and displayed with color modulation by <code>AIS</code> logic.<ul>
<li>Example: <code>AIS_TextLabel</code>.</li>
</ul>
</li>
<li>Highlighting of a secondary presentation of Interactive Object filled in by <code>PrsMgr_PresentableObject::Compute()</code> and displayed with color modulation by <code>AIS</code> logic.<ul>
<li>Example: <code>AIS_Shape</code>, displayed in <code>AIS_Shaded</code> display mode and highlighted using <code>AIS_Wireframe</code> display mode (default behavior). See also <code>PrsMgr_PresentableObject::SetHilightMode()</code>.</li>
</ul>
</li>
<li>Highlight presentation stored within a custom <code>SelectMgr_EntityOwner</code> and managed by <code>SelectMgr_EntityOwner::HilightWithColor()</code>.<ul>
<li>Example: <code>StdSelect_BRepOwner</code> for selection of sub-shapes.</li>
</ul>
</li>
<li>Custom highlight presentation stored within Interactive Object itself (see <code>SelectMgr_SelectableObject::GetHilightPresentation()</code> / <code>::GetSelectPresentation()</code> methods).<ul>
<li>Filled in by <code>SelectMgr_EntityOwner::HilightWithColor()</code> with <code>SelectMgr_SelectableObject::IsAutoHilight()</code> turned ON.<br  />
 Example: <code>AIS_PointCloud</code>.</li>
<li>Filled in by <code>SelectMgr_SelectableObject::HilightSelected()</code> with <code>SelectMgr_SelectableObject::IsAutoHilight()</code> turned OFF.<br  />
 Example: <code>MeshVS_Mesh</code>.</li>
</ul>
</li>
<li>Main presentation of Interactive Object (active display mode) filled in by <code>PrsMgr_PresentableObject::Compute()</code> and manually updated (recomputed or modified aspects) on highlight events.<ul>
<li>Example: <code>AIS_Manipulator</code>.</li>
</ul>
</li>
</ul>
<p>The number of options looks overwhelming but in general, it is better to stick to the simplest approach working for you and consider alternatives only when you have to.</p>
<h1><a class="anchor" id="mouse_click"></a>
Mouse click</h1>
<p>Dynamic highlighting is only one of scenarios where <code>SelectMgr_EntityOwner</code> could be useful. Another feature is an interface for handling a mouse click <code>SelectMgr_EntityOwner</code> <code>::HandleMouseClick()</code>.</p>
<p>This interface is useful for defining some user interface elements like buttons, and most likely your application will use a more comprehensive GUI framework for this purpose instead of <code>AIS</code>. But let's have some fun and make our object to change a color on each mouse click:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisOwner : <span class="keyword">public</span> SelectMgr_EntityOwner</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> HandleMouseClick (<span class="keyword">const</span> Graphic3d_Vec2i&amp; thePoint,</div>
<div class="line">                                 Aspect_VKeyMouse theButton,</div>
<div class="line">                                 Aspect_VKeyFlags theModifiers,</div>
<div class="line">                                 <span class="keywordtype">bool</span> theIsDoubleClick) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> MyAisOwner::HandleMouseClick (<span class="keyword">const</span> Graphic3d_Vec2i&amp; thePoint,</div>
<div class="line">                                   Aspect_VKeyMouse theButton,</div>
<div class="line">                                   Aspect_VKeyFlags theModifiers,</div>
<div class="line">                                   <span class="keywordtype">bool</span> theIsDoubleClick)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> math_BullardGenerator aRandGen;</div>
<div class="line">  Quantity_Color aRandColor (<span class="keywordtype">float</span>(aRandGen.NextInt() % 256) / 255.0f,</div>
<div class="line">                             <span class="keywordtype">float</span>(aRandGen.NextInt() % 256) / 255.0f,</div>
<div class="line">                             <span class="keywordtype">float</span>(aRandGen.NextInt() % 256) / 255.0f,</div>
<div class="line">                             Quantity_TOC_sRGB);</div>
<div class="line">  mySelectable-&gt;Attributes()-&gt;ShadingAspect()-&gt;SetColor(aRandColor);</div>
<div class="line">  mySelectable-&gt;SynchronizeAspects();</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Looks pretty simple. Now let's make things more interesting and launch some simple object animation on each click. We use a couple of global (<code>static</code>) variables in our sample for simplicity - don't do that in a real production code.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyAisOwner : <span class="keyword">public</span> SelectMgr_EntityOwner</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">  <span class="keywordtype">void</span> SetAnimation (<span class="keyword">const</span> Handle(AIS_Animation)&amp; theAnim)</div>
<div class="line">  { myAnim = theAnim; }</div>
<div class="line">...</div>
<div class="line">  Handle(AIS_Animation) myAnim;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> MyAisOwner::HandleMouseClick (<span class="keyword">const</span> Graphic3d_Vec2i&amp; thePoint,</div>
<div class="line">                                   Aspect_VKeyMouse theButton,</div>
<div class="line">                                   Aspect_VKeyFlags theModifiers,</div>
<div class="line">                                   <span class="keywordtype">bool</span> theIsDoubleClick)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> isFirst = <span class="keyword">true</span>;</div>
<div class="line">  isFirst = !isFirst;</div>
<div class="line">  MyAisObject* anObj = <span class="keyword">dynamic_cast&lt;</span>MyAisObject*<span class="keyword">&gt;</span> (mySelectable);</div>
<div class="line">  gp_Trsf aTrsfTo;</div>
<div class="line">  aTrsfTo.SetRotation (gp_Ax1 (gp::Origin(), gp::DX()),</div>
<div class="line">                       isFirst ? M_PI * 0.5 : -M_PI * 0.5);</div>
<div class="line">  gp_Trsf aTrsfFrom = anObj-&gt;LocalTransformation();</div>
<div class="line">  Handle(AIS_AnimationObject) anAnim =</div>
<div class="line">    <span class="keyword">new</span> AIS_AnimationObject (<span class="stringliteral">&quot;MyAnim&quot;</span>, anObj-&gt;InteractiveContext(),</div>
<div class="line">                             anObj, aTrsfFrom, aTrsfTo);</div>
<div class="line">  anAnim-&gt;SetOwnDuration (2.0);</div>
<div class="line"> </div>
<div class="line">  myAnim-&gt;Clear();</div>
<div class="line">  myAnim-&gt;Add (anAnim);</div>
<div class="line">  myAnim-&gt;StartTimer (0.0, 1.0, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Animation is a complex topic that is worth a dedicated article - let's not go too deep in detail here. To perform animation in a non-interrupted way, it should be handled by some class like <code>AIS_ViewController</code>, which is responsible for managing user input events and for 3D viewer updates. To utilize it, you need adding a custom object animation to <code>AIS_ViewController::ObjectsAnimation()</code> or adding custom view animation to <code>AIS_ViewController::ViewAnimation()</code>. Somewhere in application this might look like this:</p>
<div class="fragment"><div class="line">Handle(AIS_InteractiveContext) theCtx;</div>
<div class="line">Handle(AIS_ViewController) theViewCtrl;</div>
<div class="line">Handle(MyAisObject) aPrs = <span class="keyword">new</span> MyAisObject();</div>
<div class="line">aPrs-&gt;SetAnimation (theViewCtrl-&gt;ObjectsAnimation());</div>
<div class="line">theCtx-&gt;Display (aPrs, MyAisObject::MyDispMode_Main, 0, <span class="keyword">false</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="final"></a>
Final result</h1>
<p>The final sample could be seen by calling <code>QATutorialAisObject</code> command from Draw Harness plugin <code>QAcommands</code> (<code>TKQADraw</code> toolkit):</p>
<div class="fragment"><div class="line">pload VISUALIZATION QAcommands</div>
<div class="line">vinit View1</div>
<div class="line">QATutorialAisObject p</div>
<div class="line">vfit</div>
</div><!-- fragment --><p>You may also take a look onto source code of this command at <code>src/QADraw/QADraw_Tutorials.cxx</code> if you have some problems following the tutorial. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 4 2023 13:54:32 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>

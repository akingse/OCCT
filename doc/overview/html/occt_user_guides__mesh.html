<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open CASCADE Technology: Mesh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open CASCADE Technology"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('occt_user_guides__mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mesh </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_modalg_11_1">Mesh presentations</a></li>
<li class="level1"><a href="#occt_modalg_11_2">Meshing algorithm</a></li>
<li class="level1"><a href="#occt_modalg_11_3">BRepMesh Architecture</a><ul><li class="level2"><a href="#occt_modalg_11_3_1">Goals</a></li>
<li class="level2"><a href="#occt_modalg_11_3_2">General workflow</a></li>
<li class="level2"><a href="#occt_modalg_11_3_3">Common interfaces</a></li>
<li class="level2"><a href="#occt_modalg_11_3_4">Create model data structure</a><ul><li class="level3"><a href="#autotoc_md159">Data model interface</a></li>
<li class="level3"><a href="#autotoc_md160">Collecting data model</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_11_3_5">Discretize edges 3D &amp; 2D curves</a></li>
<li class="level2"><a href="#occt_modalg_11_3_6">Heal discrete model</a></li>
<li class="level2"><a href="#occt_modalg_11_3_7">Preprocess discrete model</a></li>
<li class="level2"><a href="#occt_modalg_11_3_8">Discretize faces</a><ul><li class="level3"><a href="#autotoc_md161">Range splitter</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_modalg_11_3_9">Postprocess discrete model</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_modalg_11_1"></a>
Mesh presentations</h1>
<p>In addition to support of exact geometrical representation of 3D objects Open CASCADE Technology provides functionality to work with tessellated representations of objects in form of meshes.</p>
<p>Open CASCADE Technology mesh functionality provides:</p><ul>
<li>data structures to store surface mesh data associated to shapes, and some basic algorithms to handle these data</li>
<li>data structures and algorithms to build surface triangular mesh from <em>BRep</em> objects (shapes).</li>
<li>tools to extend 3D visualization capabilities of Open CASCADE Technology with displaying meshes along with associated pre- and post-processor data.</li>
</ul>
<p>Open CASCADE Technology includes two mesh converters:</p><ul>
<li>VRML converter translates Open CASCADE shapes to VRML 1.0 files (Virtual Reality Modeling Language). Open CASCADE shapes may be translated in two representations: shaded or wireframe. A shaded representation present shapes as sets of triangles computed by a mesh algorithm while a wireframe representation present shapes as sets of curves.</li>
<li>STL converter translates Open CASCADE shapes to STL files. STL (STtereoLithography) format is widely used for rapid prototyping.</li>
</ul>
<p>Open CASCADE SAS also offers Advanced Mesh Products:</p><ul>
<li><a href="https://www.opencascade.com/content/mesh-framework">Open CASCADE Mesh Framework (OMF)</a></li>
<li><a href="https://www.opencascade.com/content/express-mesh">Express Mesh</a></li>
</ul>
<p>Besides, we can efficiently help you in the fields of surface and volume meshing algorithms, mesh optimization algorithms etc. If you require a qualified advice about meshing algorithms, do not hesitate to benefit from the expertise of our team in that domain.</p>
<p>The projects dealing with numerical simulation can benefit from using SALOME - an Open Source Framework for CAE with CAD data interfaces, generic Pre- and Post- F.E. processors and API for integrating F.E. solvers.</p>
<p>Learn more about SALOME platform on <a href="https://www.salome-platform.org">https://www.salome-platform.org</a></p>
<h1><a class="anchor" id="occt_modalg_11_2"></a>
Meshing algorithm</h1>
<p>The algorithm of shape triangulation is provided by the functionality of <em>BRepMesh_IncrementalMesh</em> class, which adds a triangulation of the shape to its topological data structure. This triangulation is used to visualize the shape in shaded mode.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;IMeshData_Status.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;IMeshTools_Parameters.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;BRepMesh_IncrementalMesh.hxx&gt;</span></div>
<div class="line"> </div>
<div class="line">Standard_Boolean meshing_explicit_parameters()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> Standard_Real aRadius = 10.0; </div>
<div class="line">  <span class="keyword">const</span> Standard_Real aHeight = 25.0; </div>
<div class="line">  BRepPrimAPI_MakeCylinder aCylinder(aRadius, aHeight); </div>
<div class="line">  TopoDS_Shape aShape = aCylinder.Shape();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Standard_Real aLinearDeflection   = 0.01;</div>
<div class="line">  <span class="keyword">const</span> Standard_Real anAngularDeflection = 0.5;</div>
<div class="line">  BRepMesh_IncrementalMesh aMesher (aShape, aLinearDeflection, Standard_False, anAngularDeflection, Standard_True);</div>
<div class="line">  <span class="keyword">const</span> Standard_Integer aStatus = aMesher.GetStatusFlags();</div>
<div class="line">  <span class="keywordflow">return</span> !aStatus;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Standard_Boolean meshing_imeshtools_parameters()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> Standard_Real aRadius = 10.0; </div>
<div class="line">  <span class="keyword">const</span> Standard_Real aHeight = 25.0; </div>
<div class="line">  BRepPrimAPI_MakeCylinder aCylinder(aRadius, aHeight); </div>
<div class="line">  TopoDS_Shape aShape = aCylinder.Shape();</div>
<div class="line">  </div>
<div class="line">  IMeshTools_Parameters aMeshParams;</div>
<div class="line">  aMeshParams.Deflection               = 0.01;</div>
<div class="line">  aMeshParams.Angle                    = 0.5;</div>
<div class="line">  aMeshParams.Relative                 = Standard_False;</div>
<div class="line">  aMeshParams.InParallel               = Standard_True;</div>
<div class="line">  aMeshParams.MinSize                  = Precision::Confusion();</div>
<div class="line">  aMeshParams.InternalVerticesMode     = Standard_True;</div>
<div class="line">  aMeshParams.ControlSurfaceDeflection = Standard_True;</div>
<div class="line"> </div>
<div class="line">  BRepMesh_IncrementalMesh aMesher (aShape, aMeshParams);</div>
<div class="line">  <span class="keyword">const</span> Standard_Integer aStatus = aMesher.GetStatusFlags();</div>
<div class="line">  <span class="keywordflow">return</span> !aStatus;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The default meshing algorithm <em>BRepMesh_IncrementalMesh</em> has two major options to define triangulation &ndash; linear and angular deflections.</p>
<p>At the first step all edges from a face are discretized according to the specified parameters.</p>
<p>At the second step, the faces are tessellated. Linear deflection limits the distance between a curve and its tessellation, whereas angular deflection limits the angle between subsequent segments in a polyline.</p>
<div class="image">
<img src="modeling_algos_image056.png" alt=""/>
<div class="caption">
Deflection parameters of BRepMesh_IncrementalMesh algorithm</div></div>
<p>There are additional options to control behavior of the meshing of face interior: <em>DeflectionInterior</em> and <em>AngleInterior</em>. <em>DeflectionInterior</em> limits the distance between triangles and the face interior. <em>AngleInterior</em> (used for tessellation of B-spline faces only) limits the angle between normals (N1, N2 and N3 in the picture) in the nodes of every link of the triangle. There is an exception for the links along the face boundary edges, "Angular Deflection" is used for them during edges discretization.</p>
<div class="image">
<img src="modeling_algos_image057.png" alt=""/>
<div class="caption">
Linear and angular interior deflections</div></div>
<p>Note that if a given value of linear deflection is less than shape tolerance then the algorithm will skip this value and will take into account the shape tolerance.</p>
<p>The application should provide deflection parameters to compute a satisfactory mesh. Angular deflection is relatively simple and allows using a default value (12-20 degrees). Linear deflection has an absolute meaning and the application should provide the correct value for its models. Giving small values may result in a too huge mesh (consuming a lot of memory, which results in a long computation time and slow rendering) while big values result in an ugly mesh.</p>
<p>For an application working in dimensions known in advance it can be reasonable to use the absolute linear deflection for all models. This provides meshes according to metrics and precision used in the application (for example, it it is known that the model will be stored in meters, 0.004 m is enough for most tasks).</p>
<p>However, an application that imports models created in other applications may not use the same deflection for all models. Note that actually this is an abnormal situation and this application is probably just a viewer for CAD models with dimensions varying by an order of magnitude. This problem can be solved by introducing the concept of a relative linear deflection with some LOD (level of detail). The level of detail is a scale factor for absolute deflection, which is applied to model dimensions.</p>
<p>Meshing covers a shape with a triangular mesh. Other than hidden line removal, you can use meshing to transfer the shape to another tool: a manufacturing tool, a shading algorithm, a finite element algorithm, or a collision algorithm.</p>
<p>You can obtain information on the shape by first exploring it. To access triangulation of a face in the shape later, use <em>BRepTool::Triangulation</em>. To access a polygon, which is the approximation of an edge of the face, use <em>BRepTool::PolygonOnTriangulation</em>.</p>
<h1><a class="anchor" id="occt_modalg_11_3"></a>
BRepMesh Architecture</h1>
<h2><a class="anchor" id="occt_modalg_11_3_1"></a>
Goals</h2>
<p>The main goals of the chosen architecture are:</p><ul>
<li>Remove tight connections between data structures, auxiliary tools and algorithms to create an extensible solution, easy for maintenance and improvements;</li>
<li>Separate the code among several functional units responsible for specific operation for the sake of simplification of debugging and readability;</li>
<li>Introduce new data structures enabling the possibility to manipulate a discrete model of a particular entity (edge, wire, face) in order to perform computations locally instead of processing the entire model;</li>
<li>Implement a new triangulation algorithm replacing the existing functionality that contains overcomplicated solutions that need to be moved to the upper level. In addition, provide the possibility to change the algorithm depending on surface type (initially to speed up meshing of planes).</li>
</ul>
<h2><a class="anchor" id="occt_modalg_11_3_2"></a>
General workflow</h2>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_001.svg" style="pointer-events: none;"></object>
<div class="caption">
General workflow of BRepMesh component</div></div>
<p>Generally, the workflow of the component can be divided into six parts:</p><ul>
<li><b>Creation of model data structure</b>: source <em>TopoDS_Shape</em> passed to algorithm is analyzed and exploded into faces and edges. The reflection corresponding to each topological entity is created in the data model. Note that underlying algorithms use the data model as input and access it via a common interface which allows creating a custom data model with necessary dependencies between particular entities (see the paragraph "Data model interface");</li>
<li><b>Discretize edges 3D &amp; 2D curves</b>: 3D curve as well as an associated set of 2D curves of each model edge is discretized in order to create a coherent skeleton used as a base in face meshing process. If an edge of the source shape already contains polygonal data which suits the specified parameters, it is extracted from the shape and stored in the model as is. Each edge is processed separately, the adjacency is not taken into account;</li>
<li><b>Heal discrete model</b>: the source <em>TopoDS_Shape</em> can contain problems, such as open wires or self-intersections, introduced during design, exchange or modification of model. In addition, some problems like self-intersections can be introduced by roughly discretized edges. This stage is responsible for analysis of a discrete model in order to detect and repair problems or to refuse further processing of a model part in case if a problem cannot be solved;</li>
<li><b>Preprocess discrete model</b>: defines actions specific to the implemented approach to be performed before meshing of faces. By default, this operation iterates over model faces, checks the consistency of existing triangulations and cleans topological faces and adjacent edges from polygonal data in case of inconsistency or marks a face of the discrete model as not required for the computation;</li>
<li><b>Discretize faces</b>: represents the core part performing mesh generation for a particular face based on 2D discrete data. This operation caches polygonal data associated with face edges in the data model for further processing and stores the generated mesh to <em>TopoDS_Face</em>;</li>
<li><b>Postprocess discrete model</b>: defines actions specific for the implemented approach to be performed after meshing of faces. By default, this operation stores polygonal data obtained at the previous stage to <em>TopoDS_Edge</em> objects of the source model.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_11_3_3"></a>
Common interfaces</h2>
<p>The component structure contains two units: <em>IMeshData</em> (see Data model interface) and <em>IMeshTools</em>, defining common interfaces for the data model and algorithmic tools correspondingly. Class <em>IMeshTools_Context</em> represents a connector between these units. The context class caches the data model as well as the tools corresponding to each of six stages of the workflow mentioned above and provides methods to call the corresponding tool safely (designed similarly to <em>IntTools_Context</em> in order to keep consistency with OCCT core tools). All stages, except for the first one, use the data model as input and perform a specific action on the entire structure. Thus, API class <em>IMeshTools_ModelAlgo</em> is defined in order to unify the interface of tools manipulating the data model. Each tool supposed to process the data model should inherit this interface enabling the possibility to cache it in context. In contrast to others, the model builder interface is defined by another class <em>IMeshTools_ModelBuilder</em> due to a different meaning of the stage. The entry point starting the entire workflow is represented by <em>IMeshTools_MeshBuilder</em>.</p>
<p>The default implementation of <em>IMeshTools_Context</em> is given in <em>BRepMesh_Context</em> class initializing the context by instances of default algorithmic tools.</p>
<p>The factory interface <em>IMeshTools_MeshAlgoFactory</em> gives the possibility to change the triangulation algorithm for a specific surface. The factory returns an instance of the triangulation algorithm via <em>IMeshTools_MeshAlgo</em> interface depending on the type of surface passed as parameter. It is supposed to be used at the face discretization stage.</p>
<p>The default implementation of AlgoFactory is given in <em>BRepMesh_MeshAlgoFactory</em> returning algorithms of different complexity chosen according to the passed surface type. In its turn, it is used as the initializer of <em>BRepMesh_FaceDiscret</em> algorithm representing the starter of face discretization stage.</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_002.svg" style="pointer-events: none;"></object>
<div class="caption">
Interface describing entry point to meshing workflow</div></div>
<p>Remaining interfaces describe auxiliary tools:</p><ul>
<li><em>IMeshTools_CurveTessellator</em>: provides a common interface to the algorithms responsible for creation of discrete polygons on 3D and 2D curves as well as tools for extraction of existing polygons from <em>TopoDS_Edge</em> allowing to obtain discrete points and the corresponding parameters on curve regardless of the implementation details (see examples of usage of derived classes <em>BRepMesh_CurveTessellator</em>, <em>BRepMesh_EdgeTessellationExtractor</em> in <em>BRepMesh_EdgeDiscret</em>);</li>
<li><em>IMeshTools_ShapeExplorer</em>: the last two interfaces represent visitor design pattern and are intended to separate iteration over elements of topological shape (edges and faces) from the operations performed on a particular element;</li>
<li><em>IMeshTools_ShapeVisitor</em>: provides a common interface for operations on edges and faces of the target topological shape. It can be used in couple with <em>IMeshTools_ShapeExplorer</em>. The default implementation available in <em>BRepMesh_ShapeVisitor</em> performs initialization of the data model. The advantage of such approach is that the implementation of <em>IMeshTools_ShapeVisitor</em> can be changed according to the specific data model whereas the shape explorer implementation remains the same.</li>
</ul>
<h2><a class="anchor" id="occt_modalg_11_3_4"></a>
Create model data structure</h2>
<p>The data structures intended to keep discrete and temporary data required by underlying algorithms are created at the first stage of the meshing procedure. Generally, the model represents dependencies between entities of the source topological shape suitable for the target task.</p>
<h3><a class="anchor" id="autotoc_md159"></a>
Data model interface</h3>
<p>Unit <em>IMeshData</em> provides common interfaces specifying the data model API used on different stages of the entire workflow. Dependencies and references of the designed interfaces are given in the figure below. A specific interface implementation depends on the target application which allows the developer to implement different models and use custom low-level data structures, e.g. different collections, either <em>NCollection</em> or STL. <em>IMeshData_Shape</em> is used as the base class for all data structures and tools keeping the topological shape in order to avoid possible copy-paste.</p>
<p>The default implementation of interfaces is given in <em>BRepMeshData</em> unit. The main aim of the default data model is to provide features performing discretization of edges in a parallel mode. Thus, curve, pcurve and other classes are based on STL containers and smart-pointers as far as <em>NCollection</em> does not provide thread-safety for some cases (e.g. <em>NCollection_Sequence</em>). In addition, it closely reflects topology of the source shape, i.e. the number of edges in the data model is equal to the number of edges in the source model; each edge contains a set of pcurves associated with its adjacent faces which allows creation of discrete polygons for all pcurves or the 3D curve of a particular edge in a separate thread.</p>
<p><b>Advantages</b>: In case of necessity, the data model (probably with algorithms for its processing) can be easily substituted by another implementation supporting another kind of dependencies between elements.</p>
<p>An additional example of a different data model is the case when it is not required to create a mesh with discrete polygons synchronized between adjacent faces, i.e. in case of necessity to speed up creation of a rough per-face tessellation used for visualization or quick computation only (the approach used in <em>XDEDRAW_Props</em>).</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_003.svg" style="pointer-events: none;"></object>
<div class="caption">
Common API of data model</div></div>
<h3><a class="anchor" id="autotoc_md160"></a>
Collecting data model</h3>
<p>At this stage the data model is filled by entities according to the topological structure of the source shape. A default implementation of the data model is given in <em>BRepMeshData</em> unit and represents the model as two sets: a set of edges and a set of faces. Each face consists of one or several wires, the first of which always represents the outer wire, while others are internal. In its turn, each wire depicts the ordered sequence of oriented edges. Each edge is characterized by a single 3D curve and zero (in case of free edge) or more 2D curves associated with faces adjacent to this edge. Both 3D and 2D curves represent a set of pairs point-parameter defined in 3D and 2D space of the reference face correspondingly. An additional difference between a curve and a pcurve is that the latter has a reference to the face it is defined for.</p>
<p>Model filler algorithm is represented by <em>BRepMesh_ShapeVisitor</em> class creating the model as a reflection to topological shape with help of <em>BRepMesh_ShapeExplorer</em> performing iteration over edges and faces of the target shape. Note that the algorithm operates on a common interface of the data model and creates a structure without any knowledge about the implementation details and underlying data structures. The entry point to collecting functionality is <em>BRepMesh_ModelBuilder</em> class.</p>
<h2><a class="anchor" id="occt_modalg_11_3_5"></a>
Discretize edges 3D &amp; 2D curves</h2>
<p>At this stage only the edges of the data model are considered. Each edge is processed separately (with the possibility to run processing in multiple threads). The edge is checked for existing polygonal data. In case if at least one representation exists and suits the meshing parameters, it is recuperated and used as reference data for tessellation of the whole set of pcurves as well as 3D curve assigned to the edge (see <em>BRepMesh_EdgeTessellationExtractor</em>). Otherwise, a new tessellation algorithm is created and used to generate the initial polygon (see <em>BRepMesh_CurveTessellator</em>) and the edge is marked as outdated. In addition, the model edge is updated by deflection as well as recomputed same range, same parameter and degeneracy parameters. See <em>BRepMesh_EdgeDiscret</em> for implementation details.</p>
<p><em>IMeshData</em> unit defines interface <em>IMeshData_ParametersListArrayAdaptor</em>, which is intended to adapt arbitrary data structures to the <em>NCollection_Array1</em> container API. This solution is made to use both <em>NCollection_Array1</em> and <em>IMeshData_Curve</em> as the source for <em>BRepMesh_EdgeParameterProvider</em> tool intended to generate a consistent parametrization taking into account the same parameter property.</p>
<h2><a class="anchor" id="occt_modalg_11_3_6"></a>
Heal discrete model</h2>
<p>In general, this stage represents a set of operations performed on the entire discrete model in order to resolve inconsistencies due to the problems caused by design, translation or rough discretization. A different sequence of operations can be performed depending on the target triangulation algorithm, e.g. there are different approaches to process self-intersections – either to amplify edges discretization by decreasing the target precision or to split links at the intersection points. At this stage the whole set of edges is considered in aggregate and their adjacency is taken into account. A default implementation of the model healer is given in <em>BRepMesh_ModelHealer</em> which performs the following actions:</p><ul>
<li>Iterates over model faces and checks their wires for consistency, i.e. whether the wires are closed and do not contain self-intersections. The data structures are designed free of collisions, thus it is possible to run processing in a parallel mode;</li>
<li>Forcibly connects the ends of adjacent edges in the parametric space, closing gaps between possible disconnected parts. The aim of this operation is to create a correct discrete model defined relatively to the parametric space of the target face taking into account connectivity and tolerances of 3D space only. This means that no specific computations are made to determine U and V tolerance;</li>
<li>Registers intersections on edges forming the face shape. Two solutions are possible in order to resolve self-intersection:<ul>
<li>Decrease deflection of a particular edge and update its discrete model. After that the workflow "intersection check – amplification" is repeated up to 5 times. As the result, target edges contain a finer tessellation and meshing continues or the face is marked by <em>IMeshData_SelfIntersectingWire</em> status and refused from further processing;</li>
<li>Split target edges by intersection point and synchronize the updated polygon with curve and remaining pcurves associated to each edge. This operation presents a more robust solution comparing to the amplification procedure with a guaranteed result, but it is more difficult for implementation from the point of view of synchronization functionality.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="occt_modalg_11_3_7"></a>
Preprocess discrete model</h2>
<p>This stage implements actions to be performed before meshing of faces. Depending on target goals it can be changed or omitted. By default, <em>BRepMesh_ModelPreProcessor</em> implements the functionality checking topological faces for consistency of existing triangulation, i.e.: consistency with the target deflection parameter; indices of nodes referenced by triangles do not exceed the number of nodes stored in a triangulation. If the face fails some checks, it is cleaned from triangulation and its adjacent edges are cleaned from existing polygons. This does not affect a discrete model and does not require any recomputation as the model keeps tessellations for the whole set of edges despite consistency of their polygons.</p>
<h2><a class="anchor" id="occt_modalg_11_3_8"></a>
Discretize faces</h2>
<p>Discretization of faces is the general part of meshing algorithm. At this stage edges tessellation data obtained and processed on previous steps is used to form contours of target faces and passed as input to the triangulation algorithm. Default implementation is provided by <em>BRepMesh_FaceDiscret</em> class which represents a starter for triangulation algorithm. It iterates over faces available in the data model, creates an instance of the triangulation algorithm according to the type of surface associated with each face via <em>IMeshTools_MeshAlgoFactory</em> and executes it. Each face is processed separately, thus it is possible to process faces in a parallel mode. The class diagram of face discretization is given in the figure below.</p>
<div class="image">
<object type="image/svg+xml" data="modeling_algos_mesh_004.svg" style="pointer-events: none;"></object>
<div class="caption">
Class diagram of face discrete stage</div></div>
<p>In general, face meshing algorithms have the following structure:</p><ul>
<li><em>BRepMesh_BaseMeshAlgo</em> implements <em>IMeshTools_MeshAlgo</em> interface and the base functionality for inherited algorithms. The main goal of this class is to initialize an instance of <em>BRepMesh_DataStructureOfDelaun</em> as well as auxiliary data structures suitable for nested algorithms using face model data passed as input parameter. Despite implementation of triangulation algorithm this structure is currently supposed as common for OCCT. However, the user is free to implement a custom algorithm and supporting data structure accessible via <em>IMeshTools_MeshAlgo</em> interface, e.g. to connect a 3-rd party meshing tool that does not support <em>TopoDS_Shape</em> out of box. For this, such structure provides the possibility to distribute connectors to various algorithms in the form of plugins;</li>
<li><em>BRepMesh_DelaunayBaseMeshAlgo</em> and <em>BRepMesh_SweepLineMeshAlgo</em> classes implement core meshing functionality operating directly on an instance of <em>BRepMesh_DataStructureOfDelaun</em>. The algorithms represent mesh generation tools adding new points from the data structure to the final mesh;</li>
<li><em>BRepMesh_NodeInsertionMeshAlgo</em> class represents a wrapper intended to extend the algorithm inherited from <em>BRepMesh_BaseMeshAlgo</em> to enable the functionality generating surface nodes and inserting them into the structure. On this level, an instance of the classification tool is created and can be used to accept-reject internal nodes. In addition, computations necessary for scaling UV coordinates of points relatively to the range specified for the corresponding direction are performed. As far as both triangulation algorithms work on static data provided by the structure, new nodes are added at the initialization stage. Surface nodes are generated by an auxiliary tool called range splitter and passed as template parameter (see Range splitter);</li>
<li>Classes <em>BRepMesh_DelaunayNodeInsertionMeshAlgo</em> and <em>BRepMesh_SweepLineNodeInsertionMeshAlgo</em> implement algorithm-specific functionality related to addition of internal nodes supplementing functionality provided by <em>BRepMesh_NodeInsertionMeshAlgo</em>;</li>
<li><em>BRepMesh_DelaunayDeflectionControlMeshAlgo</em> extends functionality of <em>BRepMesh_DelaunayNodeInsertionMeshAlgo</em> by additional procedure controlling deflection of generated triangles.</li>
</ul>
<p>BRepMesh provides user a way to switch default triangulation algorithm to a custom one, either implemented by user or available worldwide. There are three base classes that can be currently used to integrate 3rd-party algorithms:</p>
<ul>
<li><em>BRepMesh_ConstrainedBaseMeshAlgo</em> base class for tools providing generation of triangulations with constraints requiring no common processing by BRepMesh;</li>
<li><em>BRepMesh_CustomBaseMeshAlgo</em> provides the entry point for generic algorithms without support of constraints and supposed for generation of base mesh only. Constraint edges are processed using standard functionality provided by the component itself upon background mesh produced by 3rd-party solver;</li>
<li><em>BRepMesh_CustomDelaunayBaseMeshAlgo</em> contains initialization part for tools used by BRepMesh for checks or optimizations using results of 3rd-party algorithm.</li>
</ul>
<p>Meshing algorithms could be provided by implementing <em>IMeshTools_MeshAlgoFactory</em> with related interfaces and passing it to <em>BRepMesh_Context::SetFaceDiscret()</em>. OCCT comes with two base 2D meshing algorithms: <em>BRepMesh_MeshAlgoFactory</em> (used by default) and <em>BRepMesh_DelabellaMeshAlgoFactory</em>.</p>
<p>The following example demonstrates how it could be done from <em>Draw</em> environment:</p>
<div class="fragment"><div class="line">psphere s 10</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">### Default Algo ###</span></div>
<div class="line">incmesh s 0.0001 -algo <span class="keywordflow">default</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">### Delabella Algo ###</span></div>
<div class="line"><span class="preprocessor">incmesh s 0.0001 -algo delabella</span></div>
</div><!-- fragment --><p>The code snippet below shows passing a custom mesh factory to BRepMesh_IncrementalMesh:</p>
<div class="fragment"><div class="line">IMeshTools_Parameters aMeshParams;</div>
<div class="line">Handle(IMeshTools_Context) aContext = <span class="keyword">new</span> BRepMesh_Context();</div>
<div class="line">aContext-&gt;SetFaceDiscret (<span class="keyword">new</span> BRepMesh_FaceDiscret (<span class="keyword">new</span> BRepMesh_DelabellaMeshAlgoFactory()));</div>
<div class="line"> </div>
<div class="line">BRepMesh_IncrementalMesh aMesher;</div>
<div class="line">aMesher.SetShape (aShape);</div>
<div class="line">aMesher.ChangeParameters() = aMeshParams;</div>
<div class="line"> </div>
<div class="line">aMesher.Perform (aContext);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md161"></a>
Range splitter</h3>
<p>Range splitter tools provide functionality to generate internal surface nodes defined within the range computed using discrete model data. The base functionality is provided by <em>BRepMesh_DefaultRangeSplitter</em> which can be used without modifications in case of planar surface. The default splitter does not generate any internal node.</p>
<p><em>BRepMesh_ConeRangeSplitter</em>, <em>BRepMesh_CylinderRangeSplitter</em> and <em>BRepMesh_SphereRangeSplitter</em> are specializations of the default splitter intended for quick generation of internal nodes for the corresponding type of analytical surface.</p>
<p><em>BRepMesh_UVParamRangeSplitter</em> implements base functionality taking discretization points of face border into account for node generation. Its successors BRepMesh_TorusRangeSplitter and <em>BRepMesh_NURBSRangeSplitter</em> extend the base functionality for toroidal and NURBS surfaces correspondingly.</p>
<h2><a class="anchor" id="occt_modalg_11_3_9"></a>
Postprocess discrete model</h2>
<p>This stage implements actions to be performed after meshing of faces. Depending on target goals it can be changed or omitted. By default, <em>BRepMesh_ModelPostProcessor</em> commits polygonal data stored in the data model to <em>TopoDS_Edge</em>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Dec 4 2023 13:54:35 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
